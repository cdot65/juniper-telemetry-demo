{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Juniper Telemetry demo documentation # Welcome # First off, hello and welcome to the landing page of my demo\u2019s documentation. My name is Calvin and I work in the sales organization at Juniper Networks; I hope that you will find this project helpful. In this demonstration, we will deploy jtimon as a container to ingest JTI telemetry from Juniper vMX routers. Overview # Let\u2019s talk about the workflow before we get into the requirements. At the end of this page we will have deployed a Docker container running jtimon to collect the streaming telemetry sent by our routers. We will have subscribed to the telemetry path that will send our container information regarding to BGP over gRPC with SSL encryption. Assumptions made on my part # I make a lot of assumptions in this documentation, here\u2019s a short list: you have Docker installed somewhere that can reach the internet you understand the value proposition and technology that powers streaming telemetry you have access to a Juniper device with JTI installed Creating our certs # We will be using SSL certificates for this demo, and if you\u2019ve ever played with SSL you know that it can be a pain. Here are the steps I followed, as given to the readers of this great blog . Let\u2019s start off by generating a self-signed root CA: openssl genrsa -out rootCA.key 2048 openssl req -x509 -new -key ./rootCA.key -days 365 -out ./rootCA.crt Our next step is to use the rootCA to create a certificate for the jtimon container client openssl genrsa -out ./client.key 2048 openssl req -new -key ./client.key -out ./client.csr openssl x509 -req -in ./client.csr -CA ./rootCA.crt -CAkey ./rootCA.key -CAcreateserial -out ./client.crt -days 365 Finally, we will use the rootCA to create a certificate for the jtimon container client pay close attention to the fqdn for this section, it needs to match your router\u2019s hostname openssl genrsa -out ./router.key 2048 openssl req -new -key ./router.key -out ./router.csr openssl x509 -req -in ./router.csr -CA ./rootCA.crt -CAkey ./rootCA.key -CAcreateserial -out ./router.crt -days 365 cat ./router.crt ./router.key > ./router.pem Copy relevant certs to router # Let\u2019s use SCP to copy the certs to our router; only relevant files are transferred and stored in the router\u2019s /var/tmp/ directory. scp rootCA.crt client.crt router.pem root@192.168.110.11:/var/tmp/ Configure JunOS # Three steps here, each with their own commit operation. create CA profile and new local certificate load CA profile and configure streaming attributes enable the streaming of telemetry to our jtimon container create CA profile and new local certificate # We will create a new CA profile with the name of ca-profile-1 and give it an identify of ca-id-1 . set security pki ca-profile ca-profile-1 ca-identity ca-id-1 Now we will create a new certificate profile for the router and tell it where it can find the file we transferred. set security certificates local router-cert load-key-file /var/tmp/router.pem Give the box your first commit commit load CA profile and configure streaming attributes # Now that the CA profile has been created, we can associate the root CA certificate to it. run request security pki ca-certificate load ca-profile ca-profile-1 filename /var/tmp/rootCA.crt Let\u2019s set up some basic streaming parameters that will tie together our local router cert and the root CA. set system services extension-service request-response grpc ssl port 50051 set system services extension-service request-response grpc ssl local-certificate router-cert set system services extension-service request-response grpc ssl mutual-authentication certificate-authority ca-profile-1 set system services extension-service request-response grpc ssl mutual-authentication client-certificate-request require-certificate-and-verify Give the box your second commit commit enable the streaming of telemetry to our jtimon container # Final step is to configure our source endpoint parameters, in our case this will be the local router\u2019s management IP and port to listen for connections on. set system services extension-service request-response grpc ssl address 192.168.110.11 set system services extension-service request-response grpc ssl port 32767 set system services extension-service request-response grpc ssl local-certificate router-cert commit Setting up jtimon container # Nice job getting the telemetry and certs working, now we need to focus on the client side of things. Building the client container image Setting up our configuration file Execute! Building the container image # you could bypass this step if you trust that my ghcr.io/cdot65/jtimon:latest container image is sufficient We will need to build the container image before we can create a container based upon it, so let\u2019s start there first. Change into a temporary directory, we will use this place to clone the repository and build our image from. cd /var/tmp/ git clone https://github.com/nileshsimaria/jtimon.git Execute the Makefile script to build the container image. make docker If you find that you do not have Make installed on your computer, reconsider downloading my image with docker pull ghcr.io/cdot65/jtimon:latest You can test the container by running the --help flag within the container. Don\u2019t worry, the container will be destroyed as soon as it runs so you won\u2019t have to worry about cleanup. docker run -it --rm -v ${ PWD } :/var/tmp/:ro ghcr.io/cdot65/jtimon --help We will talk about these flags used when we get to the Execute! section below. Setting up our configuration file # Final thing to setup before we execute is our client\u2019s configuration file. This tells the jtimon process quite a bit of valuable information: which IP and port combination to use for communication with the router how to authenticate with the router which certs to use, and where they are located within the container what hostname the container should expect to hear from the router which OpenConfig model(s) the client would like to setup a subscription for how fast the client would like to receive these streamed messages config.json { \"host\" : \"192.168.110.11\" , \"port\" : 32767 , \"user\" : \"root\" , \"password\" : \"juniper123\" , \"cid\" : \"cid\" , \"tls\" : { \"clientcrt\" : \"/var/tmp/client.crt\" , \"clientkey\" : \"/var/tmp/client.key\" , \"ca\" : \"/var/tmp/rootCA.crt\" , \"servername\" : \"houston.dmz.home\" }, \"grpc\" : { \"ws\" : 1048576 }, \"paths\" : [ { \"path\" : \"/network-instances/network-instance/protocols/protocol/bgp/\" , \"freq\" : 30000 } ] } Execute! # Let\u2019s fire this collector up. docker run -it --rm -v ${ PWD } :/var/tmp/:ro ghcr.io/cdot65/jtimon --config /var/tmp/config.json --print Breaking down the flags used: -it is the way we tell Docker that we\u2019d like an interactive session with the container --rm tells Docker to destroy the container after it completes its task -v ${PWD}:/var/tmp/:ro says \u201cmount this local directory to the container\u2019s /var/tmp/ with read-only permissions\u201d jtimon is the actual executable --config tells jtimon where to find its config file, in our case /var/tmp/config.json --print will print the output to our terminal This page is automatically generated","title":"Homepage"},{"location":"#juniper-telemetry-demo-documentation","text":"","title":"Juniper Telemetry demo documentation"},{"location":"#welcome","text":"First off, hello and welcome to the landing page of my demo\u2019s documentation. My name is Calvin and I work in the sales organization at Juniper Networks; I hope that you will find this project helpful. In this demonstration, we will deploy jtimon as a container to ingest JTI telemetry from Juniper vMX routers.","title":"Welcome"},{"location":"#overview","text":"Let\u2019s talk about the workflow before we get into the requirements. At the end of this page we will have deployed a Docker container running jtimon to collect the streaming telemetry sent by our routers. We will have subscribed to the telemetry path that will send our container information regarding to BGP over gRPC with SSL encryption.","title":"Overview"},{"location":"#assumptions-made-on-my-part","text":"I make a lot of assumptions in this documentation, here\u2019s a short list: you have Docker installed somewhere that can reach the internet you understand the value proposition and technology that powers streaming telemetry you have access to a Juniper device with JTI installed","title":"Assumptions made on my part"},{"location":"#creating-our-certs","text":"We will be using SSL certificates for this demo, and if you\u2019ve ever played with SSL you know that it can be a pain. Here are the steps I followed, as given to the readers of this great blog . Let\u2019s start off by generating a self-signed root CA: openssl genrsa -out rootCA.key 2048 openssl req -x509 -new -key ./rootCA.key -days 365 -out ./rootCA.crt Our next step is to use the rootCA to create a certificate for the jtimon container client openssl genrsa -out ./client.key 2048 openssl req -new -key ./client.key -out ./client.csr openssl x509 -req -in ./client.csr -CA ./rootCA.crt -CAkey ./rootCA.key -CAcreateserial -out ./client.crt -days 365 Finally, we will use the rootCA to create a certificate for the jtimon container client pay close attention to the fqdn for this section, it needs to match your router\u2019s hostname openssl genrsa -out ./router.key 2048 openssl req -new -key ./router.key -out ./router.csr openssl x509 -req -in ./router.csr -CA ./rootCA.crt -CAkey ./rootCA.key -CAcreateserial -out ./router.crt -days 365 cat ./router.crt ./router.key > ./router.pem","title":"Creating our certs"},{"location":"#copy-relevant-certs-to-router","text":"Let\u2019s use SCP to copy the certs to our router; only relevant files are transferred and stored in the router\u2019s /var/tmp/ directory. scp rootCA.crt client.crt router.pem root@192.168.110.11:/var/tmp/","title":"Copy relevant certs to router"},{"location":"#configure-junos","text":"Three steps here, each with their own commit operation. create CA profile and new local certificate load CA profile and configure streaming attributes enable the streaming of telemetry to our jtimon container","title":"Configure JunOS"},{"location":"#create-ca-profile-and-new-local-certificate","text":"We will create a new CA profile with the name of ca-profile-1 and give it an identify of ca-id-1 . set security pki ca-profile ca-profile-1 ca-identity ca-id-1 Now we will create a new certificate profile for the router and tell it where it can find the file we transferred. set security certificates local router-cert load-key-file /var/tmp/router.pem Give the box your first commit commit","title":"create CA profile and new local certificate"},{"location":"#load-ca-profile-and-configure-streaming-attributes","text":"Now that the CA profile has been created, we can associate the root CA certificate to it. run request security pki ca-certificate load ca-profile ca-profile-1 filename /var/tmp/rootCA.crt Let\u2019s set up some basic streaming parameters that will tie together our local router cert and the root CA. set system services extension-service request-response grpc ssl port 50051 set system services extension-service request-response grpc ssl local-certificate router-cert set system services extension-service request-response grpc ssl mutual-authentication certificate-authority ca-profile-1 set system services extension-service request-response grpc ssl mutual-authentication client-certificate-request require-certificate-and-verify Give the box your second commit commit","title":"load CA profile and configure streaming attributes"},{"location":"#enable-the-streaming-of-telemetry-to-our-jtimon-container","text":"Final step is to configure our source endpoint parameters, in our case this will be the local router\u2019s management IP and port to listen for connections on. set system services extension-service request-response grpc ssl address 192.168.110.11 set system services extension-service request-response grpc ssl port 32767 set system services extension-service request-response grpc ssl local-certificate router-cert commit","title":"enable the streaming of telemetry to our jtimon container"},{"location":"#setting-up-jtimon-container","text":"Nice job getting the telemetry and certs working, now we need to focus on the client side of things. Building the client container image Setting up our configuration file Execute!","title":"Setting up jtimon container"},{"location":"#building-the-container-image","text":"you could bypass this step if you trust that my ghcr.io/cdot65/jtimon:latest container image is sufficient We will need to build the container image before we can create a container based upon it, so let\u2019s start there first. Change into a temporary directory, we will use this place to clone the repository and build our image from. cd /var/tmp/ git clone https://github.com/nileshsimaria/jtimon.git Execute the Makefile script to build the container image. make docker If you find that you do not have Make installed on your computer, reconsider downloading my image with docker pull ghcr.io/cdot65/jtimon:latest You can test the container by running the --help flag within the container. Don\u2019t worry, the container will be destroyed as soon as it runs so you won\u2019t have to worry about cleanup. docker run -it --rm -v ${ PWD } :/var/tmp/:ro ghcr.io/cdot65/jtimon --help We will talk about these flags used when we get to the Execute! section below.","title":"Building the container image"},{"location":"#setting-up-our-configuration-file","text":"Final thing to setup before we execute is our client\u2019s configuration file. This tells the jtimon process quite a bit of valuable information: which IP and port combination to use for communication with the router how to authenticate with the router which certs to use, and where they are located within the container what hostname the container should expect to hear from the router which OpenConfig model(s) the client would like to setup a subscription for how fast the client would like to receive these streamed messages config.json { \"host\" : \"192.168.110.11\" , \"port\" : 32767 , \"user\" : \"root\" , \"password\" : \"juniper123\" , \"cid\" : \"cid\" , \"tls\" : { \"clientcrt\" : \"/var/tmp/client.crt\" , \"clientkey\" : \"/var/tmp/client.key\" , \"ca\" : \"/var/tmp/rootCA.crt\" , \"servername\" : \"houston.dmz.home\" }, \"grpc\" : { \"ws\" : 1048576 }, \"paths\" : [ { \"path\" : \"/network-instances/network-instance/protocols/protocol/bgp/\" , \"freq\" : 30000 } ] }","title":"Setting up our configuration file"},{"location":"#execute","text":"Let\u2019s fire this collector up. docker run -it --rm -v ${ PWD } :/var/tmp/:ro ghcr.io/cdot65/jtimon --config /var/tmp/config.json --print Breaking down the flags used: -it is the way we tell Docker that we\u2019d like an interactive session with the container --rm tells Docker to destroy the container after it completes its task -v ${PWD}:/var/tmp/:ro says \u201cmount this local directory to the container\u2019s /var/tmp/ with read-only permissions\u201d jtimon is the actual executable --config tells jtimon where to find its config file, in our case /var/tmp/config.json --print will print the output to our terminal This page is automatically generated","title":"Execute!"}]}